import asyncio
import traceback
from typing import Dict, Any, List, Optional
from langchain_core.tools import StructuredTool
from pydantic import BaseModel, Field


class InsertLinesInput(BaseModel):
    file_path: str = Field(description="Path to the file to modify.")
    after_line: int = Field(
        description="Line number after which to insert the new content (1-based index). Use 0 to insert at the beginning of the file."
    )
    new_content: str = Field(
        description="New content to insert after the specified line."
    )


class InsertLines:
    """
    Tool to insert new lines after a specific line in a file loaded in FileChangeManager.
    """

    name = "InsertLines"
    description = """Inserts new content after a specified line in a file.
        This tool modifies files that have been previously loaded with LoadFileForEditing into FileChangeManager
        
        IMPORTANT: 
        - Use standard unix line endings and standard whitespaces (Use exactly same as the file content)
        - Preserve the original indentation and whitespace patterns when providing new content.
        - Match the existing code style for consistent formatting.
        - Correctly align with the surrounding code structure.
        - Ensure braces, brackets, and parentheses are properly balanced.
        - Use after_line=0 to insert at the beginning of the file.
        
        The tool will return the context of the changes, showing:
        1. The lines that were inserted
        2. A few lines of context before and after the insertion point
        3. File Diffs for the current state of FileChangeManager (Use this to confirm your changes)
        
        All changes are tracked in FileChangeManager and will be included in diffs
        generated by GenerateFileDiff when you're ready to create a patch.
        """

    def __init__(self, file_manager):
        self.file_manager = file_manager

    async def arun(
        self, file_path: str, after_line: int, new_content: str
    ) -> Dict[str, Any]:
        """
        Asynchronous method to insert lines in a file loaded in FileChangeManager.
        """
        try:
            print(f"Insert line:{after_line}\n{new_content}")
            # Check if file is loaded
            if file_path not in self.file_manager.original_files:
                return {
                    "success": False,
                    "error": {
                        "reason": "File not loaded",
                        "details": f"File '{file_path}' has not been loaded. Use LoadFileForEditing first.",
                        "file_path": file_path,
                    },
                }

            # Get context before change (a few lines before)
            context_before_start = max(1, after_line - 3)
            context_before = self.file_manager.get_lines(
                file_path, context_before_start, after_line
            )

            # Insert the lines
            try:
                self.file_manager.insert_lines(file_path, after_line, new_content)
            except ValueError as e:
                return {
                    "success": False,
                    "error": {
                        "reason": "Invalid line position",
                        "details": str(e),
                        "file_path": file_path,
                        "after_line": after_line,
                    },
                }

            # Get new content that was inserted
            new_lines = new_content.splitlines()
            insertion_start_line = after_line + 1
            insertion_end_line = after_line + len(new_lines)

            # Get context after insertion (a few lines after)
            context_after_start = insertion_end_line + 1
            context_after_end = min(
                insertion_end_line + 3,
                len(self.file_manager.get_current_content(file_path)),
            )
            context_after = self.file_manager.get_lines(
                file_path, context_after_start, context_after_end
            )

            # Format the changes for display with line numbers
            changes_context = {
                "inserted": self._format_with_line_numbers(
                    new_lines, insertion_start_line
                ),
                "context_before": self._format_with_line_numbers(
                    context_before, context_before_start
                ),
                "context_after": self._format_with_line_numbers(
                    context_after, context_after_start
                ),
            }

            # Return success response with context of changes
            return {
                "success": True,
                "message": f"Successfully inserted {len(new_lines)} lines after line {after_line} in '{file_path}'.",
                "file_path": file_path,
                "after_line": after_line,
                "insertion_start_line": insertion_start_line,
                "insertion_end_line": insertion_end_line,
                "lines_added": len(new_lines),
                "changes_context": changes_context,
                "full_context": self._generate_full_context(
                    file_path, insertion_start_line, insertion_end_line, 3
                ),
                "current_diff_state_in_file_changes_manager": self.file_manager.generate_all_diffs(),
            }

        except Exception as e:
            # Catch any unexpected errors
            return {
                "success": False,
                "error": {
                    "reason": "Error inserting lines",
                    "details": f"Error inserting lines in '{file_path}': {type(e).__name__}: {e}\n{traceback.format_exc()}",
                    "file_path": file_path,
                    "after_line": after_line,
                },
            }

    def _format_with_line_numbers(self, lines: List[str], start_line: int) -> List[str]:
        """Format lines with line numbers for display."""
        return [f"{start_line + i}: {line}" for i, line in enumerate(lines)]

    def _generate_full_context(
        self, file_path: str, start_line: int, end_line: int, context_lines: int
    ) -> str:
        """Generate a string showing the full context of the change with clear markers."""
        # Get lines before, during, and after the change
        start_context = max(1, start_line - context_lines)
        end_context = min(
            end_line + context_lines,
            len(self.file_manager.get_current_content(file_path)),
        )

        all_lines = self.file_manager.get_lines(file_path, start_context, end_context)

        # Format with line numbers and markers for the inserted section
        result = []
        for i, line in enumerate(all_lines):
            line_num = start_context + i
            if start_line <= line_num <= end_line:
                # Mark inserted lines
                result.append(f"+ {line_num}: {line}")
            else:
                result.append(f"  {line_num}: {line}")

        return "\n".join(result)

    def run(self, file_path: str, after_line: int, new_content: str) -> Dict[str, Any]:
        """
        Synchronous wrapper for the arun method.
        """
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                # If loop is already running, submit the coroutine to it
                return asyncio.run_coroutine_threadsafe(
                    self.arun(file_path, after_line, new_content), loop
                ).result()
            else:
                # If no loop is running, run the coroutine until complete
                return loop.run_until_complete(
                    self.arun(file_path, after_line, new_content)
                )
        except RuntimeError:
            # Handle cases where get_event_loop might fail
            return asyncio.run(self.arun(file_path, after_line, new_content))
        except Exception as e:
            # Catch any other unexpected errors in the synchronous wrapper
            return {
                "success": False,
                "error": {
                    "reason": "Unexpected runtime error",
                    "details": f"Error in run method: {type(e).__name__}: {e}\n{traceback.format_exc()}",
                    "file_path": file_path,
                    "after_line": after_line,
                },
            }


def insert_lines_tool(file_manager) -> StructuredTool:
    """
    Returns: StructuredTool for inserting lines in files loaded in FileChangeManager.
    """
    tool = InsertLines(file_manager)
    return StructuredTool.from_function(
        coroutine=tool.arun,
        func=tool.run,
        name=tool.name,
        description=tool.description,
        args_schema=InsertLinesInput,
    )
