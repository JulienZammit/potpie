import asyncio
import traceback
from typing import Dict, Any, List, Optional
from langchain_core.tools import StructuredTool
from pydantic import BaseModel, Field


class DeleteLinesInput(BaseModel):
    file_path: str = Field(description="Path to the file to modify.")
    start_line: int = Field(
        description="Starting line number to delete (1-based index)."
    )
    end_line: int = Field(
        description="Ending line number to delete (inclusive, 1-based index)."
    )


class DeleteLines:
    """
    Tool to delete a range of lines in a file loaded in FileChangeManager.
    """

    name = "DeleteLines"
    description = """Deletes a range of lines from a file.
        This tool modifies files that have been previously loaded with LoadFileForEditing into FileChangeManager
        
        IMPORTANT: 
        - Make sure the line range to delete is correct to avoid unintended data loss.
        - Verify that removing these lines won't break code structure or syntax.
        - Double-check that the start_line and end_line specify the exact range you want to remove.
        - Be careful when deleting structural elements like function declarations, class definitions, or block delimiters.
        
        The tool will return the context of the changes, showing:
        1. The lines that were deleted
        2. A few lines of context before and after the deletion point
        
        All changes are tracked in FileChangeManager and will be included in diffs
        generated by GenerateFileDiff when you're ready to create a patch.
        """

    def __init__(self, file_manager):
        self.file_manager = file_manager

    async def arun(
        self, file_path: str, start_line: int, end_line: int
    ) -> Dict[str, Any]:
        """
        Asynchronous method to delete lines in a file loaded in FileChangeManager.
        """
        try:
            # Check if file is loaded
            if file_path not in self.file_manager.original_files:
                return {
                    "success": False,
                    "error": {
                        "reason": "File not loaded",
                        "details": f"File '{file_path}' has not been loaded. Use LoadFileForEditing first.",
                        "file_path": file_path,
                    },
                }

            # Get original content before making changes
            original_content = self.file_manager.get_lines(
                file_path, start_line, end_line
            )

            # Get context before deletion (a few lines before)
            context_before_start = max(1, start_line - 3)
            context_before = self.file_manager.get_lines(
                file_path, context_before_start, start_line - 1
            )

            # Current length of file before deletion
            original_file_length = len(self.file_manager.get_current_content(file_path))

            # Delete the lines
            try:
                self.file_manager.delete_lines(file_path, start_line, end_line)
            except ValueError as e:
                return {
                    "success": False,
                    "error": {
                        "reason": "Invalid line range",
                        "details": str(e),
                        "file_path": file_path,
                        "start_line": start_line,
                        "end_line": end_line,
                    },
                }

            # Get context after deletion (a few lines after the deletion point)
            context_after_start = start_line  # After deletion, this is the first line after the deleted region
            context_after_end = min(
                context_after_start + 3,
                len(self.file_manager.get_current_content(file_path)),
            )
            context_after = self.file_manager.get_lines(
                file_path, context_after_start, context_after_end
            )

            # Format the changes for display with line numbers
            changes_context = {
                "deleted": self._format_with_line_numbers(original_content, start_line),
                "context_before": self._format_with_line_numbers(
                    context_before, context_before_start
                ),
                "context_after": self._format_with_line_numbers(
                    context_after, context_after_start
                ),
            }

            # Return success response with context of changes
            return {
                "success": True,
                "message": f"Successfully deleted lines {start_line}-{end_line} in '{file_path}'.",
                "file_path": file_path,
                "start_line": start_line,
                "end_line": end_line,
                "lines_removed": end_line - start_line + 1,
                "original_file_length": original_file_length,
                "new_file_length": len(
                    self.file_manager.get_current_content(file_path)
                ),
                "changes_context": changes_context,
                "full_context": self._generate_full_context(
                    file_path, start_line, context_before, context_after
                ),
            }

        except Exception as e:
            # Catch any unexpected errors
            return {
                "success": False,
                "error": {
                    "reason": "Error deleting lines",
                    "details": f"Error deleting lines in '{file_path}': {type(e).__name__}: {e}\n{traceback.format_exc()}",
                    "file_path": file_path,
                    "start_line": start_line,
                    "end_line": end_line,
                },
            }

    def _format_with_line_numbers(self, lines: List[str], start_line: int) -> List[str]:
        """Format lines with line numbers for display."""
        return [f"{start_line + i}: {line}" for i, line in enumerate(lines)]

    def _generate_full_context(
        self,
        file_path: str,
        deletion_point: int,
        context_before: List[str],
        context_after: List[str],
    ) -> str:
        """Generate a string showing the full context of the deletion with clear markers."""
        result = []

        # Add context before with line numbers
        for line in context_before:
            result.append(f"  {line}")

        # Add a marker for where deletion occurred
        result.append(
            f"- {deletion_point}: --- {len(context_before) + 1} lines deleted ---"
        )

        # Add context after with line numbers
        for line in context_after:
            result.append(f"  {line}")

        return "\n".join(result)

    def run(self, file_path: str, start_line: int, end_line: int) -> Dict[str, Any]:
        """
        Synchronous wrapper for the arun method.
        """
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                # If loop is already running, submit the coroutine to it
                return asyncio.run_coroutine_threadsafe(
                    self.arun(file_path, start_line, end_line), loop
                ).result()
            else:
                # If no loop is running, run the coroutine until complete
                return loop.run_until_complete(
                    self.arun(file_path, start_line, end_line)
                )
        except RuntimeError:
            # Handle cases where get_event_loop might fail
            return asyncio.run(self.arun(file_path, start_line, end_line))
        except Exception as e:
            # Catch any other unexpected errors in the synchronous wrapper
            return {
                "success": False,
                "error": {
                    "reason": "Unexpected runtime error",
                    "details": f"Error in run method: {type(e).__name__}: {e}\n{traceback.format_exc()}",
                    "file_path": file_path,
                    "start_line": start_line,
                    "end_line": end_line,
                },
            }


def delete_lines_tool(file_manager) -> StructuredTool:
    """
    Returns: StructuredTool for deleting lines in files loaded in FileChangeManager.
    """
    tool = DeleteLines(file_manager)
    return StructuredTool.from_function(
        coroutine=tool.arun,
        func=tool.run,
        name=tool.name,
        description=tool.description,
        args_schema=DeleteLinesInput,
    )
