import asyncio
import traceback
from typing import Dict, Any, List, Optional
from langchain_core.tools import StructuredTool
from pydantic import BaseModel, Field


class ReplaceLinesInput(BaseModel):
    file_path: str = Field(description="Path to the file to modify.")
    start_line: int = Field(
        description="Starting line number to replace (1-based index)."
    )
    end_line: int = Field(
        description="Ending line number to replace (inclusive, 1-based index)."
    )
    new_content: str = Field(
        description="New content to replace the specified lines with."
    )


class ReplaceLines:
    """
    Tool to replace a range of lines in a file loaded in FileChangeManager.
    """

    name = "ReplaceLines"
    description = """Replaces a range of lines in a file with new content.
        This tool modifies files that have been previously loaded with LoadFileForEditing into FileChangeManager
        
        IMPORTANT: 
        - Preserve the original indentation and whitespace patterns when providing new content.
        - Match the existing code style for consistent formatting.
        - Correctly align with the surrounding code structure.
        - Ensure braces, brackets, and parentheses are properly balanced.
        
        The tool will return the context of the changes, showing:
        1. The original lines that were replaced
        2. The new content that was inserted
        3. A few lines of context before and after the change
        
        All changes are tracked in FileChangeManager and will be included in diffs
        generated by GenerateFileDiff when you're ready to create a patch.
        """

    def __init__(self, file_manager):
        self.file_manager = file_manager

    async def arun(
        self, file_path: str, start_line: int, end_line: int, new_content: str
    ) -> Dict[str, Any]:
        """
        Asynchronous method to replace lines in a file loaded in FileChangeManager.
        """
        try:
            # Check if file is loaded
            if file_path not in self.file_manager.original_files:
                return {
                    "success": False,
                    "error": {
                        "reason": "File not loaded",
                        "details": f"File '{file_path}' has not been loaded. Use LoadFileForEditing first.",
                        "file_path": file_path,
                    },
                }

            # Get original content before making changes for comparison
            original_content = self.file_manager.get_lines(
                file_path, start_line, end_line
            )

            # Get context before change (a few lines before)
            context_before_start = max(1, start_line - 3)
            context_before = self.file_manager.get_lines(
                file_path, context_before_start, start_line - 1
            )

            # Replace the lines
            try:
                self.file_manager.replace_lines(
                    file_path, start_line, end_line, new_content
                )
            except ValueError as e:
                return {
                    "success": False,
                    "error": {
                        "reason": "Invalid line range",
                        "details": str(e),
                        "file_path": file_path,
                        "start_line": start_line,
                        "end_line": end_line,
                    },
                }

            # Get new content after replacement
            new_lines = new_content.splitlines()
            new_end_line = start_line + len(new_lines) - 1

            # Get context after change (a few lines after)
            context_after_end = min(
                new_end_line + 3, len(self.file_manager.get_current_content(file_path))
            )
            context_after = self.file_manager.get_lines(
                file_path, new_end_line + 1, context_after_end
            )

            # Format the changes for display with line numbers
            changes_context = {
                "original": self._format_with_line_numbers(
                    original_content, start_line
                ),
                "new": self._format_with_line_numbers(new_lines, start_line),
                "context_before": self._format_with_line_numbers(
                    context_before, context_before_start
                ),
                "context_after": self._format_with_line_numbers(
                    context_after, new_end_line + 1
                ),
            }

            # Return success response with context of changes
            return {
                "success": True,
                "message": f"Successfully replaced lines {start_line}-{end_line} with {len(new_lines)} new lines in '{file_path}'.",
                "file_path": file_path,
                "start_line": start_line,
                "original_end_line": end_line,
                "new_end_line": new_end_line,
                "lines_removed": end_line - start_line + 1,
                "lines_added": len(new_lines),
                "net_change": len(new_lines) - (end_line - start_line + 1),
                "changes_context": changes_context,
                "full_context": self._generate_full_context(
                    file_path, start_line, new_end_line, 3
                ),
            }

        except Exception as e:
            # Catch any unexpected errors
            return {
                "success": False,
                "error": {
                    "reason": "Error replacing lines",
                    "details": f"Error replacing lines in '{file_path}': {type(e).__name__}: {e}\n{traceback.format_exc()}",
                    "file_path": file_path,
                    "start_line": start_line,
                    "end_line": end_line,
                },
            }

    def _format_with_line_numbers(self, lines: List[str], start_line: int) -> List[str]:
        """Format lines with line numbers for display."""
        return [f"{start_line + i}: {line}" for i, line in enumerate(lines)]

    def _generate_full_context(
        self, file_path: str, start_line: int, end_line: int, context_lines: int
    ) -> str:
        """Generate a string showing the full context of the change with clear markers."""
        # Get lines before, during, and after the change
        start_context = max(1, start_line - context_lines)
        end_context = min(
            end_line + context_lines,
            len(self.file_manager.get_current_content(file_path)),
        )

        all_lines = self.file_manager.get_lines(file_path, start_context, end_context)

        # Format with line numbers and markers for the changed section
        result = []
        for i, line in enumerate(all_lines):
            line_num = start_context + i
            if start_line <= line_num <= end_line:
                # Mark changed lines
                result.append(f"â†’ {line_num}: {line}")
            else:
                result.append(f"  {line_num}: {line}")

        return "\n".join(result)

    def run(
        self, file_path: str, start_line: int, end_line: int, new_content: str
    ) -> Dict[str, Any]:
        """
        Synchronous wrapper for the arun method.
        """
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                # If loop is already running, submit the coroutine to it
                return asyncio.run_coroutine_threadsafe(
                    self.arun(file_path, start_line, end_line, new_content), loop
                ).result()
            else:
                # If no loop is running, run the coroutine until complete
                return loop.run_until_complete(
                    self.arun(file_path, start_line, end_line, new_content)
                )
        except RuntimeError:
            # Handle cases where get_event_loop might fail
            return asyncio.run(self.arun(file_path, start_line, end_line, new_content))
        except Exception as e:
            # Catch any other unexpected errors in the synchronous wrapper
            return {
                "success": False,
                "error": {
                    "reason": "Unexpected runtime error",
                    "details": f"Error in run method: {type(e).__name__}: {e}\n{traceback.format_exc()}",
                    "file_path": file_path,
                    "start_line": start_line,
                    "end_line": end_line,
                },
            }


def replace_lines_tool(file_manager) -> StructuredTool:
    """
    Returns: StructuredTool for replacing lines in files loaded in FileChangeManager.
    """
    tool = ReplaceLines(file_manager)
    return StructuredTool.from_function(
        coroutine=tool.arun,
        func=tool.run,
        name=tool.name,
        description=tool.description,
        args_schema=ReplaceLinesInput,
    )
