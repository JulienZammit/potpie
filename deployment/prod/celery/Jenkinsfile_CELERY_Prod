pipeline {
    agent any

    parameters {
        string(name: 'namespace', defaultValue: "micro-services", description: 'namespace to deploy')
    }
    environment {
        // Access environment variables using Jenkins credentials
        DOCKER_REGISTRY = credentials('celery-api-docker-registry')
        GKE_CLUSTER = credentials('mom-core-gke-cluster')
        GKE_ZONE = credentials('gke-zone')
        GCP_PROJECT = credentials('gcp-project')
        GOOGLE_APPLICATION_CREDENTIALS = credentials('google-application-credentials')
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    // Clean workspace first
                    deleteDir()
                    
                    // Determine environment based on branch
                    def branch = env.GIT_BRANCH

                    if (branch == "origin/dir-restruct") {
                        env.ENVIRONMENT = 'dir-restruct'
                    } else if (branch == "origin/main"){
                        env.ENVIRONMENT = 'main'  // Fixed typo: ENVIORNMENT â†’ ENVIRONMENT
                    } else {
                        error("Unknown branch: ${branch}. This pipeline only supports main and staging branches.")
                    }

                    checkout scm
                    
                    // Capture the short Git commit hash to use as the image tag
                    env.GIT_COMMIT_HASH = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim()
                    env.GIT_COMMIT_FULL = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
                    
                    echo "Building for branch: ${branch}"
                    echo "Commit hash: ${env.GIT_COMMIT_HASH}"
                    echo "Full commit: ${env.GIT_COMMIT_FULL}"
                    echo "Current workspace: ${env.WORKSPACE}"
                    
                    // Debug: Show git status and recent commits
                    sh """
                        echo "=== Git Status ==="
                        git status
                        echo "=== Recent Commits ==="
                        git log --oneline -5
                        echo "=== Current Branch ==="
                        git branch -a
                        echo "=== Remote URL ==="
                        git remote -v
                    """
                }
            }
        }

        stage('Configure Docker Authentication') {
            steps {
                script {
                    // Extract the registry's hostname for authentication
                    def registryHost = env.DOCKER_REGISTRY.tokenize('/')[0]
                    sh """
                        sudo gcloud auth configure-docker ${registryHost}
                    """
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    // Use the Git commit hash as the image tag
                    def imageTag = env.GIT_COMMIT_HASH
                    def dockerRegistry = env.DOCKER_REGISTRY
                    
                    echo "Building Docker image with tag: ${imageTag}"
                    echo "Docker registry: ${dockerRegistry}"
                    echo "Current workspace: ${env.WORKSPACE}"
                    echo "Current directory contents:"
                    sh "ls -la"
                    
                    // Use current workspace instead of hardcoded path
                    sh """
                        sudo docker build \
                            --build-arg GIT_COMMIT_HASH=${imageTag} \
                            --no-cache \
                            -f deployment/prod/celery/celery.Dockerfile \
                            -t ${DOCKER_REGISTRY}/celery-api:${imageTag} \
                            ${env.WORKSPACE}
                    """
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    // Use the Git commit hash as the image tag
                    def imageTag = env.GIT_COMMIT_HASH
                    echo "Pushing image with tag: ${imageTag}"
                    sh "whoami && pwd"
                    sh "sudo docker push ${DOCKER_REGISTRY}/celery-api:${imageTag}"
                }
            }
        }

        stage('Configure GKE Authentication') {
            steps {
                script {
                    // Use the service account path from credentials
                    sh """
                    sudo gcloud auth activate-service-account --key-file=${GOOGLE_APPLICATION_CREDENTIALS}
                    sudo gcloud container clusters get-credentials ${GKE_CLUSTER} --zone ${GKE_ZONE} --project ${GCP_PROJECT}
                    """
                }
            }
        }

        stage('Ask User for Deployment Confirmation') {
            steps {
                script {
                    def deployConfirmation = input(
                        id: 'userInput',
                        message: 'Do you want to deploy the new Docker image?',
                        parameters: [
                            choice(name: 'Deploy', choices: ['Yes', 'No'], description: 'Select Yes to proceed to deploy the image or No to abort.')
                        ]
                    )

                    if (deployConfirmation == 'No') {
                        error('User chose not to deploy the images, stopping the pipeline.')
                    }
                }
            }
        }

        stage('Deploy Image') {
            steps {
                script {
                    def imageDeploySucceeded = false
                    def imageTag = env.GIT_COMMIT_HASH

                    echo "Deploying image with tag: ${imageTag}"
                    echo "Full image: ${DOCKER_REGISTRY}/celery-api:${imageTag}"

                    try {
                        // Verify the deployment exists before updating
                        sh """
                        kubectl describe deployment/celery-api-deployment -n ${params.namespace} || echo "Deployment not found"
                        """
                        
                        sh """
                        kubectl set image deployment/celery-api-deployment celery-api=${DOCKER_REGISTRY}/celery-api:${imageTag} -n ${params.namespace}
                        kubectl rollout status deployment/celery-api-deployment -n ${params.namespace} --timeout=300s
                        """
                        imageDeploySucceeded = true
                    } catch (Exception e) {
                        echo "Deployment failed: ${e}"
                    }

                    if (!imageDeploySucceeded) {
                        echo 'Rolling back to previous revision...'
                        sh "kubectl rollout undo deployment/celery-api-deployment -n ${params.namespace}"
                        sh "kubectl rollout status deployment/celery-api-deployment -n ${params.namespace}"
                    }
                }
            }
        }

        stage('Pipeline finished') {
            steps {
                script {
                    echo "Pipeline finished successfully"
                    // Check the deployment status
                    sh """
                    echo "Checking deployment status:"
                    kubectl get pods -n ${params.namespace} -l app=celery-api
                    kubectl describe deployment/celery-api-deployment -n ${params.namespace}
                    """
                }
            }
        }
    }

    post {
        always {
            echo "Pipeline cleanup"
            // Optional cleanup action
            script {
                // Clean up local Docker images
                def imageTag = env.GIT_COMMIT_HASH
                if (imageTag) {
                    sh """
                    docker rmi ${DOCKER_REGISTRY}/celery-api:${imageTag} || true
                    """
                }
            }
        }
    }
}